const PDFTable = require('pdfkit-table');

const generatePDFReport = (config) => {
  return new Promise((resolve, reject) => {
    const {
      title = 'Report',
      period = 'CUSTOM',
      dateRange = {},
      generatedOn = new Date(),
      sections = []
    } = config;

    const doc = new PDFTable({
      margin: 30,
      size: 'A4',
      bufferPages: true
    });

    const chunks = [];
    doc.on('data', (chunk) => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    // ====== HEADER ======
    doc.rect(0, 0, doc.page.width, 100).fill('#374151');
    doc.fillColor('#ffffff');
    doc.fontSize(20).font('Helvetica-Bold').text(title.toUpperCase(), { align: 'center', y: 30 });
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica').text(`Report Period: ${period.toUpperCase()}`, { align: 'center' });

    if (dateRange.start && dateRange.end) {
      const startDate = new Date(dateRange.start).toLocaleDateString();
      const endDate = new Date(dateRange.end).toLocaleDateString();
      doc.text(`Date Range: ${startDate} - ${endDate}`, { align: 'center' });
    }

    doc.text(`Generated on: ${generatedOn.toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}`, { align: 'center' });

    doc.y = 120;
    doc.fillColor('#2b2d42');

    // ====== SECTION PROCESSOR ======
    const processSection = async (section, index) => {
      // ✅ Add page only if previous content reached near bottom
      if (doc.y > 500) doc.addPage();

      doc.fontSize(14).font('Helvetica-Bold').text(section.title, { underline: true });
      doc.moveDown(0.5);

      if (section.type === 'content' && Array.isArray(section.content)) {
        section.content.forEach((summary) => {
          doc.rect(30, doc.y, doc.page.width - 60, 70)
            .fillOpacity(0.1)
            .fill('#f8f9fa')
            .fillOpacity(1);

          doc.fontSize(10).font('Helvetica-Bold').fillColor('#7a7c83ff').text(`Period: ${summary.period}`);
          doc.fontSize(9).font('Helvetica').fillColor('#2b2d42')
            .text(`Total Orders: ${summary.totalOrders}`)
            .text(`Paid Orders: ${summary.paidOrders}`)
            .text(`COD Orders: ${summary.codOrders}`)
            .text(`Refunded Orders: ${summary.refundedOrders}`)
            .text(`Total Revenue: ₹${summary.totalRevenue.toLocaleString('en-IN')}.00`)
            .text(`Success Rate: ${summary.successRate}%`);
          doc.moveDown(1);
        });
      } else if (section.table) {
        await doc.table(section.table, {
          prepareHeader: () => {
            doc.font('Helvetica-Bold')
              .fontSize(section.headerFontSize || 9)
              .fillColor('#2b2525ff');
          },
          prepareRow: (row, i) => {
            doc.font('Helvetica')
              .fontSize(section.rowFontSize || 8)
              .fillColor('#2b2d42');
          },
          divider: {
            header: { width: 1, opacity: 0.8 },
            horizontal: { width: 0.5, opacity: 0.3 }
          },
          columnsSize: [90, 70, 130, 30, 60, 60, 60],
        });
      }
    };

    // ====== MAIN FLOW ======
    const processAllSections = async () => {
      for (let i = 0; i < sections.length; i++) {
        await processSection(sections[i], i);
      }

      doc.flushPages();
      const totalPages = doc.bufferedPageRange().count;

      for (let i = 0; i < totalPages; i++) {
        doc.switchToPage(i);
        doc.fillColor('#2b2d42').fontSize(8)
          .text(`Page ${i + 1} of ${totalPages}`, 30, doc.page.height - 30, {
            align: 'center',
            width: doc.page.width - 60
          })
          .text('Generated by Order Management System', 30, doc.page.height - 20, {
            align: 'center',
            width: doc.page.width - 60
          });
      }

      doc.end();
    };

    processAllSections().catch(reject);
  });
};

module.exports = generatePDFReport;
